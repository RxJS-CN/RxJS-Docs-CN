---
children:
  - label: '我有一个已存在的 Observable， 然后'
    children:
    - label: 我想改变每一个发出的值，
      children:
      - label: 这个值是个常量
        children:
        - label: mapTo
      - label: 这个值是通过公式计算得到的
        children:
        - label: map
    - label: 我想从每个发出的值中选取一个属性
      children:
      - label: pluck
    - label: 我想在不影响发出的值的情况下窥探它们
      children:
      - label: do
    - label: 我想只允许某些值通过，做法是
      children:
      - label: 基于自定义逻辑
        children:
        - label: filter
      - label: 如果通过的值是在 Observable 起始处，并且
        children:
        - label: 只要第一个值
          children:
          - label: first
        - label: 基于给定的数量
          children:
          - label: take
        - label: 基于自定义逻辑
          children:
          - label: takeWhile
      - label: 如果它正好是第n个发出的值
        children:
        - label: elementAt
      - label: 如果通过的值是在 Observable 结尾处，并且
        children:
        - label: 只要最后一个值
          children:
          - label: last
        - label: 基于给定的数量
          children:
          - label: takeLast
      - label: 直到另一个 Observable 发出值或完成
        children:
        - label: takeUntil
    - label: 我想忽略某些值，做法是
      children:
      - label: 全部忽略
        children:
        - label: ignoreElements
      - label: 从 Observable 的起始处，并且
        children:
        - label: 基于给定的数量
          children:
          - label: skip
        - label: 基于自定义逻辑
          children:
          - label: skipWhile
      - label: 从 Observable 的结尾处
        children:
        - label: skipLast
      - label: 直到另一个 Observabler 发出值
        children:
        - label: skipUntil
      - label: 匹配一些前面的值，
        children:
        - label: 根据值是否相等，并且
          children:
          - label: 比较的是上一个值
            children:
            - label: distinctUntilChanged
          - label: 比较的是过去一段时间内
            children:
            - label: distinct
        - label: 根据键值或对象属性，并且
          children:
          - label: 比较的是上一个值
            children:
            - label: distinctUntilKeyChanged
      - label: 针对那么发生频率过高的，然后
        children:
        - label: 只发出每个时间窗口内的第一个值，并且
          children:
          - label: 时间窗口取决于由另外一个 Observable 的发送
            children:
            - label: throttle
          - label: 时间窗口取决于时间区间
            children:
            - label: throttleTime
        - label: 只发出每个时间窗口内的最后一个值，并且
          children:
          - label: 时间窗口取决于由另外一个 Observable 的发送
            children:
            - label: audit
          - label: 时间窗口取决于时间区间
            children:
            - label: auditTime
        - label: 一旦沉默的时间足够长的话，就发出最后一个值，并且
          children:
          - label: 沉默持续时间阈值取决于另外一个 Observable
            children:
            - label: debounce
          - label: 沉默持续时间阈值取决于时间区间
            children:
            - label: debounceTime
    - label: I want to compute a formula using all values emitted
      children:
      - label: and only output the final computed value
        children:
        - label: reduce
      - label: and output the computed values when the source emits a value
        children:
        - label: scan
      - label: and output the computed values as a nested Observable when the source emits a value
        children:
        - label: mergeScan
    - label: I want to wrap its messages with metadata
      children:
      - label: that describes each notification (next, error, or complete)
        children:
        - label: materialize
      - label: that includes the time past since the last emitted value
        children:
        - label: timeInterval
    - label: after a period of inactivity
      children:
      - label: I want to throw an error
        children:
        - label: timeout
      - label: I want to switch to another Observable
        children:
        - label: timeoutWith
    - label: I want to ensure there is only one value
      children:
      - label: single
    - label: I want to know how many values it emits
      children:
      - label: count
    - label: I want to prepend one value
      children:
      - label: startWith
    - label: I want to delay the emissions
      children:
      - label: based on a given amount of time
        children:
        - label: delay
      - label: based on the emissions of another Observable
        children:
        - label: delayWhen
    - label: I want to group the values
      children:
      - label: until the Observable completes
        children:
        - label: and convert to an array
          children:
          - label: toArray
        - label: and convert to a Promise
          children:
          - label: toPromise
      - label: consecutively in pairs, as arrays
        children:
        - label: pairwise
      - label: 'based on a criterion, and output two Observables: those that match the criterion and those that do not'
        children:
        - label: partition
      - label: in batches of a particular size
        children:
        - label: and emit the group as an array
          children:
          - label: bufferCount
        - label: and emit the group as a nested Observable
          children:
          - label: windowCount
      - label: based on time
        children:
        - label: and emit the group as an array
          children:
          - label: bufferTime
        - label: and emit the group as a nested Observable
          children:
          - label: windowTime
      - label: until another Observable emits
        children:
        - label: and emit the group as an array
          children:
          - label: buffer
        - label: and emit the group as a nested Observable
          children:
          - label: window
      - label: based on the emissions of an Observable created on-demand
        children:
        - label: and emit the group as an array
          children:
          - label: bufferWhen
        - label: and emit the group as a nested Observable
          children:
          - label: windowWhen
      - label: based on another Observable for opening a group, and an Observable for closing a group
        children:
        - label: and emit the group as an array
          children:
          - label: bufferToggle
        - label: and emit the group as a nested Observable
          children:
          - label: windowToggle
      - label: based on a key calculated from the emitted values
        children:
        - label: groupBy
    - label: I want to start a new Observable for each value
      children:
      - label: and emit the values from all nested Observables in parallel
        children:
        - label: where the nested Observable is the same for every value
          children:
          - label: mergeMapTo
        - label: where the nested Observable is calculated for each value
          children:
          - label: mergeMap
      - label: and emit the values from each nested Observable in order
        children:
        - label: where the nested Observable is the same for every value
          children:
          - label: concatMapTo
        - label: where the nested Observable is calculated for each value
          children:
          - label: concatMap
      - label: and cancel the previous nested Observable when a new value arrives
        children:
        - label: where the nested Observable is the same for every value
          children:
          - label: switchMapTo
        - label: where the nested Observable is calculated for each value
          children:
          - label: switchMap
      - label: and ignore incoming values while the current nested Observable has not yet completed
        children:
        - label: exhaustMap
      - label: and recursively start a new Observable for each new value
        children:
        - label: expand
    - label: I want to perform custom operations without breaking the chained calls API
      children:
      - label: let
    - label: I want to share a subscription between multiple subscribers
      children:
      - label: using a conventional Subject
        children:
        - label: and start it as soon as the first subscriber arrives
          children:
          - label: share
        - label: and start it manually or imperatively
          children:
          - label: publish
      - label: using a BehaviorSubject
        children:
        - label: publishBehavior
      - label: using a ReplaySubject
        children:
        - label: publishReplay
      - label: using an AsyncSubject
        children:
        - label: publishLast
      - label: using a specific subject implementation
        children:
        - label: multicast
      - label: and make it behave like a cache
        children:
        - label: cache
    - label: when an error occurs
      children:
      - label: I want to start a new Observable
        children:
        - label: catch
      - label: I want to re-subscribe
        children:
        - label: immediately
          children:
          - label: retry
        - label: when another Observable emits
          children:
          - label: retryWhen
    - label: when it completes
      children:
      - label: I want to re-subscribe
        children:
          - label: immediately
            children:
            - label: repeat
          - label: when another Observable emits
            children:
            - label: repeatWhen
      - label: I want to start a new Observable
        children:
        - label: concat
    - label: when it completes, errors or unsubscribes, I want to execute a function
      children:
      - label: finally
    - label: I want to change the scheduler
      children:
      - label: that routes calls to subscribe
        children:
        - label: subscribeOn
      - label: that routes values to observers
        children:
        - label: observeOn
    - label: I want to combine this Observable with others, and
      children:
      - label: I want to receive values only from the Observable that emits a value first
        children:
        - label: race
      - label: I want to output the values from either of them
        children:
        - label: Observable.merge
      - label: I want to output a value computed from values of the source Observables
        children:
        - label: using the latest value of each source whenever any source emits
          children:
          - label: combineLatest
        - label: using the latest value of each source only when the primary Observable emits
          children:
          - label: withLatestFrom
        - label: using each source value only once
          children:
          - label: zip
  - label: '我把一些 Observables 组合成了一个 Observable，然后'
    children:
    - label: 我只想从首先发出值的 Observable 中接收值
      children:
      - label: Observable.race
    - label: 我想所有的 Observables 都完成后再通知我
      children:
      - label: Observable.forkJoin
    - label: 我想输出任何一个 Observable 的值
      children:
      - label: Observable.merge
    - label: 我想输出的值是根据源 Observables 计算出来的，并且
      children:
      - label: 当任意源发出值时使用每个源的最后一个值
        children:
        - label: Observable.combineLatest
      - label: 每个源的值只使用一次
        children:
        - label: Observable.zip
    - label: 我想按顺序订阅每一个 Observable 
      children:
      - label: Observable.concat
  - label: '我还没有 Observable， 然后'
    children:
    - label: 我想创建一个新的 Observable，它
      children:
      - label: 使用自定义逻辑
        children:
        - label: Observable.create
      - label: 使用类似于 for 循环的状态机
        children:
        - label: Observable.generate
      - label: 抛出错误
        children:
        - label: Observable.throw
      - label: 只是完成流而不发出任何值
        children:
        - label: Observable.empty
      - label: 从不发出任何东西
        children:
        - label: Observable.never
      - label: 来自已存在的事件源
        children:
        - label: 来自 DOM 或 Node.js 或其他类似的
          children:
          - label: Observable.fromEvent
        - label: 使用 API 来添加或移除事件处理方法
          children:
          - label: Observable.fromEventPattern
      - label: 来自 ES6 的 Promise
        children:
        - label: Observable.fromPromise
      - label: 来自 Promise 或事件源或数组
        children:
        - label: Observable.from
      - label: 迭代
        children:
        - label: 数组中的值
          children:
          - label: Observable.fromArray
        - label: 数字区间中的值
          children:
          - label: Observable.range
        - label: 预先被指定为参数的值
          children:
          - label: Observable.of
      - label: 在定时器上发出值，并且
        children:
        - label: 是有规律的
          children:
          - label: Observable.interval
        - label: 具有可选的初始延迟时间
          children:
          - label: Observable.timer
      - label: 被订阅时才会按需建立
        children:
        - label: Observable.defer
    - label: 我想把回调函数转换成 Observable，它
      children:
      - label: 支持传统的回调函数 API
        children:
        - label: Observable.bindCallback
      - label: 支持 Node.js 风格的回调函数 API
        children:
        - label: Observable.bindNodeCallback
